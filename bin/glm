#!/usr/bin/env bash
set -euo pipefail

SUBAGENT_DIR="${HOME}/.claude/subagents"
CONFIG_DIR="${HOME}/.config/GoLeM"
ZAI_ENV="$CONFIG_DIR/zai_api_key"
[[ -f "$ZAI_ENV" ]] || ZAI_ENV="${HOME}/.config/zai/env"
CLAUDE_BIN="$(command -v claude 2>/dev/null || echo "")"
DEFAULT_TIMEOUT=3000
DEFAULT_PERMISSION_MODE="bypassPermissions"
DEFAULT_MAX_PARALLEL=3

# Load config
GLM_CONF="$CONFIG_DIR/glm.conf"
if [[ -f "$GLM_CONF" ]]; then
    source "$GLM_CONF"
fi
PERMISSION_MODE="${GLM_PERMISSION_MODE:-$DEFAULT_PERMISSION_MODE}"
MAX_PARALLEL="${GLM_MAX_PARALLEL:-$DEFAULT_MAX_PARALLEL}"

if [[ -z "$CLAUDE_BIN" ]]; then
    echo "ERROR: claude CLI not found in PATH" >&2
    exit 1
fi

SYSTEM_PROMPT='You are a subagent. Respond ONLY in this exact format:

STATUS: OK | ERR_NO_FILES | ERR_PARSE | ERR_ACCESS | ERR_PERMISSION | ERR_TIMEOUT | ERR_UNKNOWN
FILES: [comma-separated list of files you read or modified, or "none"]
---
[your concise answer here â€” no greetings, no filler, no markdown headers]

Rules:
- Be extremely concise. No preamble, no "Sure!", no "Here is...".
- For code: output raw code only, no wrapping explanation.
- For analysis: use bullet points, max 1 line each.
- For errors: STATUS line + one-line description of what went wrong.
- Never repeat the prompt back. Never explain what you are about to do.
- If the task involves multiple files, use "--- FILE: path ---" separators.'

# Source Z.AI credentials
if [[ ! -f "$ZAI_ENV" ]]; then
    echo "ERROR: Z.AI credentials not found at $ZAI_ENV" >&2
    echo "Run install.sh or create manually:" >&2
    echo "  mkdir -p ~/.config/GoLeM" >&2
    echo "  echo 'ZAI_API_KEY=\"your-key\"' > ~/.config/GoLeM/zai_api_key" >&2
    echo "  chmod 600 ~/.config/GoLeM/zai_api_key" >&2
    exit 1
fi
source "$ZAI_ENV"

if [[ -z "${ZAI_API_KEY:-}" ]]; then
    echo "ERROR: ZAI_API_KEY is empty in $ZAI_ENV" >&2
    exit 1
fi

mkdir -p "$SUBAGENT_DIR"

generate_job_id() {
    echo "job-$(date +%Y%m%d-%H%M%S)-$(head -c4 /dev/urandom | xxd -p)"
}

count_running_jobs() {
    local count=0
    for job_dir in "$SUBAGENT_DIR"/job-*; do
        [[ -d "$job_dir" ]] || continue
        local status
        status=$(cat "$job_dir/status" 2>/dev/null || echo "")
        if [[ "$status" == "running" || "$status" == "pending" ]]; then
            if [[ -f "$job_dir/pid.txt" ]]; then
                local pid
                pid=$(cat "$job_dir/pid.txt")
                if kill -0 "$pid" 2>/dev/null; then
                    count=$((count + 1))
                fi
            fi
        fi
    done
    echo "$count"
}

wait_for_slot() {
    [[ "$MAX_PARALLEL" -le 0 ]] && return 0  # 0 = unlimited
    while true; do
        local running
        running=$(count_running_jobs)
        if [[ "$running" -lt "$MAX_PARALLEL" ]]; then
            return 0
        fi
        sleep 2
    done
}

execute_claude() {
    local prompt="$1"
    local workdir="$2"
    local timeout="$3"
    local job_dir="$4"
    local perm_mode="$5"

    echo "$prompt" > "$job_dir/prompt.txt"
    echo "$workdir" > "$job_dir/workdir.txt"
    echo "$perm_mode" > "$job_dir/permission_mode.txt"
    date -Iseconds > "$job_dir/started_at.txt"
    echo "running" > "$job_dir/status"

    # Build permission flags
    local perm_flags=()
    if [[ "$perm_mode" == "bypassPermissions" ]]; then
        perm_flags+=(--dangerously-skip-permissions)
    else
        perm_flags+=(--permission-mode "$perm_mode")
    fi

    local exit_code=0
    cd "$workdir"
    env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        ANTHROPIC_AUTH_TOKEN="$ZAI_API_KEY" \
        ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic" \
        API_TIMEOUT_MS="3000000" \
        ANTHROPIC_DEFAULT_OPUS_MODEL="glm-5" \
        ANTHROPIC_DEFAULT_SONNET_MODEL="glm-5" \
        ANTHROPIC_DEFAULT_HAIKU_MODEL="glm-5" \
        timeout "${timeout}s" \
        "$CLAUDE_BIN" -p \
            "${perm_flags[@]}" \
            --no-session-persistence \
            --model sonnet \
            --output-format json \
            --append-system-prompt "$SYSTEM_PROMPT" \
            "$prompt" \
        > "$job_dir/raw.json" 2> "$job_dir/stderr.txt" \
    || exit_code=$?

    # Extract text result from JSON
    if [[ -s "$job_dir/raw.json" ]]; then
        # Parse JSON: extract result text and changelog
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
except:
    sys.exit(0)

# Extract final text result
result = data.get('result', '')
with open('$job_dir/stdout.txt', 'w') as f:
    f.write(result)

# Extract changelog from tool calls
changes = []
for msg in data.get('messages', []):
    if msg.get('role') != 'assistant':
        continue
    for block in msg.get('content', []):
        if block.get('type') != 'tool_use':
            continue
        tool = block.get('name', '')
        inp = block.get('input', {})
        if tool == 'Edit':
            changes.append(f'EDIT {inp.get(\"file_path\", \"?\")}: {len(inp.get(\"new_string\", \"\"))} chars')
        elif tool == 'Write':
            changes.append(f'WRITE {inp.get(\"file_path\", \"?\")}')
        elif tool == 'Bash':
            cmd = inp.get('command', '')
            if any(w in cmd for w in ['rm ', 'rm -', 'rmdir', 'unlink']):
                changes.append(f'DELETE via bash: {cmd[:80]}')
            elif any(w in cmd for w in ['mv ', 'cp ', 'mkdir']):
                changes.append(f'FS: {cmd[:80]}')
        elif tool == 'NotebookEdit':
            changes.append(f'NOTEBOOK {inp.get(\"notebook_path\", \"?\")}')

with open('$job_dir/changelog.txt', 'w') as f:
    for c in changes:
        f.write(c + '\n')
    if not changes:
        f.write('(no file changes)\n')
" < "$job_dir/raw.json"
    else
        touch "$job_dir/stdout.txt" "$job_dir/changelog.txt"
    fi

    if [[ $exit_code -eq 0 ]]; then
        echo "done" > "$job_dir/status"
    elif [[ $exit_code -eq 124 ]]; then
        echo "timeout" > "$job_dir/status"
    else
        # Detect permission errors in stderr
        if grep -qi 'permission\|not allowed\|denied\|unauthorized' "$job_dir/stderr.txt" 2>/dev/null; then
            echo "permission_error" > "$job_dir/status"
        else
            echo "failed" > "$job_dir/status"
        fi
        echo "$exit_code" > "$job_dir/exit_code.txt"
    fi
    date -Iseconds > "$job_dir/finished_at.txt"

    # Print changelog to stderr if there were changes
    if [[ -s "$job_dir/changelog.txt" ]] && ! grep -q '(no file changes)' "$job_dir/changelog.txt"; then
        echo "--- CHANGELOG ($job_dir) ---" >&2
        cat "$job_dir/changelog.txt" >&2
    fi
}

cmd_run() {
    local workdir="." timeout="$DEFAULT_TIMEOUT" prompt="" perm_mode="$PERMISSION_MODE"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d) workdir="$2"; shift 2 ;;
            -t) timeout="$2"; shift 2 ;;
            --unsafe) perm_mode="bypassPermissions"; shift ;;
            --mode) perm_mode="$2"; shift 2 ;;
            *)  prompt="$*"; break ;;
        esac
    done

    if [[ -z "$prompt" ]]; then
        echo "ERROR: No prompt provided" >&2
        exit 1
    fi

    wait_for_slot

    local job_id
    job_id=$(generate_job_id)
    local job_dir="$SUBAGENT_DIR/$job_id"
    mkdir -p "$job_dir"

    execute_claude "$prompt" "$workdir" "$timeout" "$job_dir" "$perm_mode"
    cat "$job_dir/stdout.txt"
}

cmd_start() {
    local workdir="." timeout="$DEFAULT_TIMEOUT" prompt="" perm_mode="$PERMISSION_MODE"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d) workdir="$2"; shift 2 ;;
            -t) timeout="$2"; shift 2 ;;
            --unsafe) perm_mode="bypassPermissions"; shift ;;
            --mode) perm_mode="$2"; shift 2 ;;
            *)  prompt="$*"; break ;;
        esac
    done

    if [[ -z "$prompt" ]]; then
        echo "ERROR: No prompt provided" >&2
        exit 1
    fi

    wait_for_slot

    local job_id
    job_id=$(generate_job_id)
    local job_dir="$SUBAGENT_DIR/$job_id"
    mkdir -p "$job_dir"
    echo "pending" > "$job_dir/status"

    execute_claude "$prompt" "$workdir" "$timeout" "$job_dir" "$perm_mode" &
    echo "$!" > "$job_dir/pid.txt"

    echo "$job_id"
}

cmd_status() {
    local job_id="$1"
    local job_dir="$SUBAGENT_DIR/$job_id"

    if [[ ! -d "$job_dir" ]]; then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    local status
    status=$(cat "$job_dir/status")

    if [[ "$status" == "running" || "$status" == "pending" ]] && [[ -f "$job_dir/pid.txt" ]]; then
        local pid
        pid=$(cat "$job_dir/pid.txt")
        if ! kill -0 "$pid" 2>/dev/null; then
            echo "failed" > "$job_dir/status"
            status="failed"
        fi
    fi

    echo "$status"
}

cmd_result() {
    local job_id="$1"
    local job_dir="$SUBAGENT_DIR/$job_id"

    if [[ ! -d "$job_dir" ]]; then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    local status
    status=$(cat "$job_dir/status")

    if [[ "$status" == "running" || "$status" == "pending" ]]; then
        echo "ERROR: Job $job_id is still $status" >&2
        exit 1
    fi

    if [[ "$status" == "failed" || "$status" == "timeout" ]]; then
        echo "WARNING: Job $job_id ended with status: $status" >&2
        if [[ -s "$job_dir/stderr.txt" ]]; then
            echo "--- STDERR ---" >&2
            cat "$job_dir/stderr.txt" >&2
        fi
    fi

    cat "$job_dir/stdout.txt"
}

cmd_log() {
    local job_id="$1"
    local job_dir="$SUBAGENT_DIR/$job_id"

    if [[ ! -d "$job_dir" ]]; then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    if [[ -f "$job_dir/changelog.txt" ]]; then
        cat "$job_dir/changelog.txt"
    else
        echo "(no changelog)"
    fi
}

cmd_list() {
    printf "%-40s %-10s %-25s\n" "JOB_ID" "STATUS" "STARTED"
    printf "%-40s %-10s %-25s\n" "------" "------" "-------"
    for job_dir in "$SUBAGENT_DIR"/job-*; do
        [[ -d "$job_dir" ]] || continue
        local job_id status started
        job_id=$(basename "$job_dir")
        status=$(cat "$job_dir/status" 2>/dev/null || echo "unknown")
        started=$(cat "$job_dir/started_at.txt" 2>/dev/null || echo "?")
        printf "%-40s %-10s %-25s\n" "$job_id" "$status" "$started"
    done
}

cmd_clean() {
    local days=3
    if [[ "${1:-}" == "--days" ]]; then
        days="${2:-3}"
    fi
    find "$SUBAGENT_DIR" -maxdepth 1 -name "job-*" -type d -mtime "+$days" -exec rm -rf {} +
    echo "Cleaned jobs older than $days days"
}

cmd_kill() {
    local job_id="$1"
    local job_dir="$SUBAGENT_DIR/$job_id"

    if [[ ! -f "$job_dir/pid.txt" ]]; then
        echo "ERROR: No PID file for $job_id" >&2
        exit 1
    fi

    local pid
    pid=$(cat "$job_dir/pid.txt")
    if kill -0 "$pid" 2>/dev/null; then
        kill -TERM "$pid" 2>/dev/null
        sleep 1
        kill -KILL "$pid" 2>/dev/null || true
        echo "killed" > "$job_dir/status"
        echo "Killed job $job_id (PID $pid)"
    else
        echo "Job $job_id is not running (PID $pid already dead)"
    fi
}

case "${1:-}" in
    run)    shift; cmd_run "$@" ;;
    start)  shift; cmd_start "$@" ;;
    status) shift; cmd_status "$@" ;;
    result) shift; cmd_result "$@" ;;
    log)    shift; cmd_log "$@" ;;
    list)   shift; cmd_list "$@" ;;
    clean)  shift; cmd_clean "$@" ;;
    kill)   shift; cmd_kill "$@" ;;
    *)
        cat <<'USAGE'
Usage: glm {run|start|status|result|log|list|clean|kill} [options]

Commands:
  run   [-d DIR] [-t SEC] [--unsafe] "prompt"   Sync execution
  start [-d DIR] [-t SEC] [--unsafe] "prompt"   Async execution
  status  JOB_ID                                 Check job status
  result  JOB_ID                                 Get text output
  log     JOB_ID                                 Show file changes
  list                                           List all jobs
  clean   [--days N]                             Remove old jobs
  kill    JOB_ID                                 Terminate job

Flags:
  --unsafe         Bypass all permission checks
  --mode MODE      Set permission mode (acceptEdits, default, plan)

Config: ~/.config/GoLeM/glm.conf
  GLM_PERMISSION_MODE=acceptEdits   # default permission mode
  GLM_MAX_PARALLEL=3                # max concurrent agents (0=unlimited)

Per-job files:
  stdout.txt       Text result
  changelog.txt    File modifications log
  raw.json         Full JSON with all tool calls
USAGE
        exit 1
        ;;
esac
