#!/usr/bin/env bash
set -euo pipefail

SUBAGENT_DIR="${HOME}/.claude/subagents"
CONFIG_DIR="${HOME}/.config/GoLeM"
ZAI_ENV="$CONFIG_DIR/zai_api_key"
[[ -f "$ZAI_ENV" ]] || ZAI_ENV="${HOME}/.config/zai/env"
CLAUDE_BIN="$(command -v claude 2>/dev/null || echo "")"
DEFAULT_TIMEOUT=3000
DEFAULT_PERMISSION_MODE="bypassPermissions"
DEFAULT_MAX_PARALLEL=3
DEFAULT_MODEL="glm-4.7"

# Load config
GLM_CONF="$CONFIG_DIR/glm.conf"
if [[ -f "$GLM_CONF" ]]; then
    source "$GLM_CONF"
fi
PERMISSION_MODE="${GLM_PERMISSION_MODE:-$DEFAULT_PERMISSION_MODE}"
MAX_PARALLEL="${GLM_MAX_PARALLEL:-$DEFAULT_MAX_PARALLEL}"
MODEL="${GLM_MODEL:-$DEFAULT_MODEL}"
OPUS_MODEL="${GLM_OPUS_MODEL:-$MODEL}"
SONNET_MODEL="${GLM_SONNET_MODEL:-$MODEL}"
HAIKU_MODEL="${GLM_HAIKU_MODEL:-$MODEL}"

if [[ -z "$CLAUDE_BIN" ]]; then
    echo "ERROR: claude CLI not found in PATH" >&2
    exit 1
fi

SYSTEM_PROMPT='You are a subagent. Respond ONLY in this exact format:

STATUS: OK | ERR_NO_FILES | ERR_PARSE | ERR_ACCESS | ERR_PERMISSION | ERR_TIMEOUT | ERR_UNKNOWN
FILES: [comma-separated list of files you read or modified, or "none"]
---
[your concise answer here â€” no greetings, no filler, no markdown headers]

Rules:
- Be extremely concise. No preamble, no "Sure!", no "Here is...".
- For code: output raw code only, no wrapping explanation.
- For analysis: use bullet points, max 1 line each.
- For errors: STATUS line + one-line description of what went wrong.
- Never repeat the prompt back. Never explain what you are about to do.
- If the task involves multiple files, use "--- FILE: path ---" separators.'

# Source Z.AI credentials
if [[ ! -f "$ZAI_ENV" ]]; then
    echo "ERROR: Z.AI credentials not found at $ZAI_ENV" >&2
    echo "Run install.sh or create manually:" >&2
    echo "  mkdir -p ~/.config/GoLeM" >&2
    echo "  echo 'ZAI_API_KEY=\"your-key\"' > ~/.config/GoLeM/zai_api_key" >&2
    echo "  chmod 600 ~/.config/GoLeM/zai_api_key" >&2
    exit 1
fi
source "$ZAI_ENV"

if [[ -z "${ZAI_API_KEY:-}" ]]; then
    echo "ERROR: ZAI_API_KEY is empty in $ZAI_ENV" >&2
    exit 1
fi

mkdir -p "$SUBAGENT_DIR"

generate_job_id() {
    echo "job-$(date +%Y%m%d-%H%M%S)-$(head -c4 /dev/urandom | xxd -p)"
}

resolve_project_id() {
    local dir="${1:-.}"
    local abs_dir
    abs_dir="$(cd "$dir" 2>/dev/null && pwd)" || abs_dir="$dir"

    # Use git root if available, otherwise the directory itself
    local root
    root="$(git -C "$abs_dir" rev-parse --show-toplevel 2>/dev/null)" || root="$abs_dir"

    # basename + cksum hash for readability + uniqueness
    local name hash
    name="$(basename "$root")"
    hash="$(printf '%s' "$root" | cksum | cut -d' ' -f1)"
    echo "${name}-${hash}"
}

find_job_dir() {
    local job_id="$1"
    # Current project first
    local project_id
    project_id=$(resolve_project_id ".")
    if [[ -d "$SUBAGENT_DIR/$project_id/$job_id" ]]; then
        echo "$SUBAGENT_DIR/$project_id/$job_id"
        return 0
    fi
    # Legacy flat structure
    if [[ -d "$SUBAGENT_DIR/$job_id" ]]; then
        echo "$SUBAGENT_DIR/$job_id"
        return 0
    fi
    # Search all projects
    local proj_dir
    for proj_dir in "$SUBAGENT_DIR"/*/; do
        [[ -d "$proj_dir" ]] || continue
        if [[ -d "${proj_dir}${job_id}" ]]; then
            echo "${proj_dir}${job_id}"
            return 0
        fi
    done
    return 1
}

count_running_jobs() {
    local count=0
    local job_dir
    # Search project-scoped dirs and legacy flat structure
    for job_dir in "$SUBAGENT_DIR"/*/job-* "$SUBAGENT_DIR"/job-*; do
        [[ -d "$job_dir" ]] || continue
        local status
        status=$(cat "$job_dir/status" 2>/dev/null || echo "")
        if [[ "$status" == "running" ]]; then
            if [[ -f "$job_dir/pid.txt" ]]; then
                local pid
                pid=$(cat "$job_dir/pid.txt")
                if kill -0 "$pid" 2>/dev/null; then
                    count=$((count + 1))
                fi
            fi
        fi
    done
    echo "$count"
}

# Atomically claim a slot using mkdir lock (portable across Linux/macOS)
wait_for_slot() {
    local job_dir="$1"
    [[ "$MAX_PARALLEL" -le 0 ]] && return 0  # 0 = unlimited
    local lockdir="$SUBAGENT_DIR/.slot_lock"
    # Clean stale lock (crash recovery)
    if [[ -d "$lockdir" ]]; then
        local lock_age
        lock_age=$(( $(date +%s) - $(stat -c %Y "$lockdir" 2>/dev/null || stat -f %m "$lockdir" 2>/dev/null || echo 0) ))
        if [[ "$lock_age" -gt 60 ]]; then
            rmdir "$lockdir" 2>/dev/null || true
        fi
    fi
    while true; do
        if mkdir "$lockdir" 2>/dev/null; then
            local running
            running=$(count_running_jobs)
            if [[ "$running" -lt "$MAX_PARALLEL" ]]; then
                echo "running" > "$job_dir/status"
                rmdir "$lockdir"
                return 0
            fi
            rmdir "$lockdir"
        fi
        sleep 2
    done
}

execute_claude() {
    local prompt="$1"
    local workdir="$2"
    local timeout="$3"
    local job_dir="$4"
    local perm_mode="$5"
    local opus="$6"
    local sonnet="$7"
    local haiku="$8"

    echo "$prompt" > "$job_dir/prompt.txt"
    echo "$workdir" > "$job_dir/workdir.txt"
    echo "$perm_mode" > "$job_dir/permission_mode.txt"
    echo "opus=$opus sonnet=$sonnet haiku=$haiku" > "$job_dir/model.txt"
    date -Iseconds > "$job_dir/started_at.txt"
    echo "running" > "$job_dir/status"

    # Build permission flags
    local perm_flags=()
    if [[ "$perm_mode" == "bypassPermissions" ]]; then
        perm_flags+=(--dangerously-skip-permissions)
    else
        perm_flags+=(--permission-mode "$perm_mode")
    fi

    local exit_code=0
    cd "$workdir"
    env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        ANTHROPIC_AUTH_TOKEN="$ZAI_API_KEY" \
        ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic" \
        API_TIMEOUT_MS="3000000" \
        ANTHROPIC_DEFAULT_OPUS_MODEL="$opus" \
        ANTHROPIC_DEFAULT_SONNET_MODEL="$sonnet" \
        ANTHROPIC_DEFAULT_HAIKU_MODEL="$haiku" \
        timeout "${timeout}s" \
        "$CLAUDE_BIN" -p \
            "${perm_flags[@]}" \
            --no-session-persistence \
            --model sonnet \
            --output-format json \
            --append-system-prompt "$SYSTEM_PROMPT" \
            "$prompt" \
        > "$job_dir/raw.json" 2> "$job_dir/stderr.txt" \
    || exit_code=$?

    # Extract text result from JSON
    if [[ -s "$job_dir/raw.json" ]]; then
        # Parse JSON: extract result text and changelog
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
except:
    sys.exit(0)

# Extract final text result
result = data.get('result', '')
with open('$job_dir/stdout.txt', 'w') as f:
    f.write(result)

# Extract changelog from tool calls
changes = []
for msg in data.get('messages', []):
    if msg.get('role') != 'assistant':
        continue
    for block in msg.get('content', []):
        if block.get('type') != 'tool_use':
            continue
        tool = block.get('name', '')
        inp = block.get('input', {})
        if tool == 'Edit':
            changes.append(f'EDIT {inp.get(\"file_path\", \"?\")}: {len(inp.get(\"new_string\", \"\"))} chars')
        elif tool == 'Write':
            changes.append(f'WRITE {inp.get(\"file_path\", \"?\")}')
        elif tool == 'Bash':
            cmd = inp.get('command', '')
            if any(w in cmd for w in ['rm ', 'rm -', 'rmdir', 'unlink']):
                changes.append(f'DELETE via bash: {cmd[:80]}')
            elif any(w in cmd for w in ['mv ', 'cp ', 'mkdir']):
                changes.append(f'FS: {cmd[:80]}')
        elif tool == 'NotebookEdit':
            changes.append(f'NOTEBOOK {inp.get(\"notebook_path\", \"?\")}')

with open('$job_dir/changelog.txt', 'w') as f:
    for c in changes:
        f.write(c + '\n')
    if not changes:
        f.write('(no file changes)\n')
" < "$job_dir/raw.json"
    else
        touch "$job_dir/stdout.txt" "$job_dir/changelog.txt"
    fi

    if [[ $exit_code -eq 0 ]]; then
        echo "done" > "$job_dir/status"
    elif [[ $exit_code -eq 124 ]]; then
        echo "timeout" > "$job_dir/status"
    else
        # Detect permission errors in stderr
        if grep -qi 'permission\|not allowed\|denied\|unauthorized' "$job_dir/stderr.txt" 2>/dev/null; then
            echo "permission_error" > "$job_dir/status"
        else
            echo "failed" > "$job_dir/status"
        fi
        echo "$exit_code" > "$job_dir/exit_code.txt"
    fi
    date -Iseconds > "$job_dir/finished_at.txt"

    # Print changelog to stderr if there were changes
    if [[ -s "$job_dir/changelog.txt" ]] && ! grep -q '(no file changes)' "$job_dir/changelog.txt"; then
        echo "--- CHANGELOG ($job_dir) ---" >&2
        cat "$job_dir/changelog.txt" >&2
    fi
}

cmd_run() {
    local workdir="." timeout="$DEFAULT_TIMEOUT" prompt="" perm_mode="$PERMISSION_MODE"
    local opus="$OPUS_MODEL" sonnet="$SONNET_MODEL" haiku="$HAIKU_MODEL"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d) workdir="$2"; shift 2 ;;
            -t) timeout="$2"; shift 2 ;;
            -m|--model)  opus="$2"; sonnet="$2"; haiku="$2"; shift 2 ;;
            --opus)      opus="$2"; shift 2 ;;
            --sonnet)    sonnet="$2"; shift 2 ;;
            --haiku)     haiku="$2"; shift 2 ;;
            --unsafe) perm_mode="bypassPermissions"; shift ;;
            --mode) perm_mode="$2"; shift 2 ;;
            *)  prompt="$*"; break ;;
        esac
    done

    if [[ -z "$prompt" ]]; then
        echo "ERROR: No prompt provided" >&2
        exit 1
    fi

    local project_id job_id
    project_id=$(resolve_project_id "$workdir")
    job_id=$(generate_job_id)
    local job_dir="$SUBAGENT_DIR/$project_id/$job_id"
    mkdir -p "$job_dir"
    echo "queued" > "$job_dir/status"
    echo "$$" > "$job_dir/pid.txt"

    wait_for_slot "$job_dir"

    execute_claude "$prompt" "$workdir" "$timeout" "$job_dir" "$perm_mode" "$opus" "$sonnet" "$haiku"
    cat "$job_dir/stdout.txt"
    rm -rf "$job_dir"
}

cmd_start() {
    local workdir="." timeout="$DEFAULT_TIMEOUT" prompt="" perm_mode="$PERMISSION_MODE"
    local opus="$OPUS_MODEL" sonnet="$SONNET_MODEL" haiku="$HAIKU_MODEL"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d) workdir="$2"; shift 2 ;;
            -t) timeout="$2"; shift 2 ;;
            -m|--model)  opus="$2"; sonnet="$2"; haiku="$2"; shift 2 ;;
            --opus)      opus="$2"; shift 2 ;;
            --sonnet)    sonnet="$2"; shift 2 ;;
            --haiku)     haiku="$2"; shift 2 ;;
            --unsafe) perm_mode="bypassPermissions"; shift ;;
            --mode) perm_mode="$2"; shift 2 ;;
            *)  prompt="$*"; break ;;
        esac
    done

    if [[ -z "$prompt" ]]; then
        echo "ERROR: No prompt provided" >&2
        exit 1
    fi

    local project_id job_id
    project_id=$(resolve_project_id "$workdir")
    job_id=$(generate_job_id)
    local job_dir="$SUBAGENT_DIR/$project_id/$job_id"
    mkdir -p "$job_dir"
    echo "$prompt" > "$job_dir/prompt.txt"
    date -Iseconds > "$job_dir/started_at.txt"
    echo "queued" > "$job_dir/status"

    echo "$job_id"

    # Run in background: wait for slot, then execute
    (
        wait_for_slot "$job_dir"
        execute_claude "$prompt" "$workdir" "$timeout" "$job_dir" "$perm_mode" "$opus" "$sonnet" "$haiku"
    ) &
    echo "$!" > "$job_dir/pid.txt"
}

cmd_status() {
    local job_id="$1"
    local job_dir
    if ! job_dir=$(find_job_dir "$job_id"); then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    local status
    status=$(cat "$job_dir/status")

    if [[ "$status" == "running" || "$status" == "queued" ]] && [[ -f "$job_dir/pid.txt" ]]; then
        local pid
        pid=$(cat "$job_dir/pid.txt")
        if ! kill -0 "$pid" 2>/dev/null; then
            echo "failed" > "$job_dir/status"
            status="failed"
        fi
    fi

    echo "$status"
}

cmd_result() {
    local job_id="$1"
    local job_dir
    if ! job_dir=$(find_job_dir "$job_id"); then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    local status
    status=$(cat "$job_dir/status")

    if [[ "$status" == "running" || "$status" == "queued" ]]; then
        echo "ERROR: Job $job_id is still $status" >&2
        exit 1
    fi

    if [[ "$status" == "failed" || "$status" == "timeout" ]]; then
        echo "WARNING: Job $job_id ended with status: $status" >&2
        if [[ -s "$job_dir/stderr.txt" ]]; then
            echo "--- STDERR ---" >&2
            cat "$job_dir/stderr.txt" >&2
        fi
    fi

    cat "$job_dir/stdout.txt"
    rm -rf "$job_dir"
}

cmd_log() {
    local job_id="$1"
    local job_dir
    if ! job_dir=$(find_job_dir "$job_id"); then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    if [[ -f "$job_dir/changelog.txt" ]]; then
        cat "$job_dir/changelog.txt"
    else
        echo "(no changelog)"
    fi
}

cmd_list() {
    printf "%-40s %-10s %-25s\n" "JOB_ID" "STATUS" "STARTED"
    printf "%-40s %-10s %-25s\n" "------" "------" "-------"
    for job_dir in "$SUBAGENT_DIR"/*/job-* "$SUBAGENT_DIR"/job-*; do
        [[ -d "$job_dir" ]] || continue
        local job_id status started
        job_id=$(basename "$job_dir")
        status=$(cat "$job_dir/status" 2>/dev/null || echo "unknown")
        started=$(cat "$job_dir/started_at.txt" 2>/dev/null || echo "?")
        # Fix stale running/queued jobs whose process is dead
        if [[ "$status" == "running" || "$status" == "queued" ]] && [[ -f "$job_dir/pid.txt" ]]; then
            local pid
            pid=$(cat "$job_dir/pid.txt")
            if ! kill -0 "$pid" 2>/dev/null; then
                status="failed"
                echo "failed" > "$job_dir/status"
            fi
        fi
        printf "%-40s %-10s %-25s\n" "$job_id" "$status" "$started"
    done
}

cmd_clean() {
    local days="" count=0
    if [[ "${1:-}" == "--days" ]]; then
        days="${2:-3}"
    fi

    if [[ -n "$days" ]]; then
        # Time-based cleanup: remove jobs older than N days
        while IFS= read -r -d '' job_dir; do
            rm -rf "$job_dir"
            count=$((count + 1))
        done < <(find "$SUBAGENT_DIR" -maxdepth 2 -name "job-*" -type d -mtime "+$days" -print0)
        echo "Cleaned $count jobs older than $days days"
    else
        # Status-based cleanup: remove all finished jobs (done/failed/timeout/killed)
        for job_dir in "$SUBAGENT_DIR"/*/job-* "$SUBAGENT_DIR"/job-*; do
            [[ -d "$job_dir" ]] || continue
            local status
            status=$(cat "$job_dir/status" 2>/dev/null || echo "unknown")
            case "$status" in
                done|failed|timeout|killed)
                    rm -rf "$job_dir"
                    count=$((count + 1))
                    ;;
            esac
        done
        echo "Cleaned $count finished jobs"
    fi
}

cmd_kill() {
    local job_id="$1"
    local job_dir
    if ! job_dir=$(find_job_dir "$job_id"); then
        echo "ERROR: Job $job_id not found" >&2
        exit 1
    fi

    if [[ ! -f "$job_dir/pid.txt" ]]; then
        echo "ERROR: No PID file for $job_id" >&2
        exit 1
    fi

    local pid
    pid=$(cat "$job_dir/pid.txt")
    if kill -0 "$pid" 2>/dev/null; then
        kill -TERM "$pid" 2>/dev/null
        sleep 1
        kill -KILL "$pid" 2>/dev/null || true
        echo "killed" > "$job_dir/status"
        echo "Killed job $job_id (PID $pid)"
    else
        echo "Job $job_id is not running (PID $pid already dead)"
    fi
}

cmd_update() {
    local GREEN='\033[0;32m' YELLOW='\033[1;33m' RED='\033[0;31m' NC='\033[0m'
    _info()  { echo -e "${GREEN}[+]${NC} $1"; }
    _warn()  { echo -e "${YELLOW}[!]${NC} $1"; }
    _err()   { echo -e "${RED}[x]${NC} $1" >&2; }

    # Resolve the repo dir from this script's real path
    local script_path repo_dir
    script_path="$(readlink -f "$0")"
    repo_dir="$(cd "$(dirname "$script_path")/.." && pwd)"

    if [[ ! -d "$repo_dir/.git" ]]; then
        _err "Cannot find GoLeM repo at $repo_dir"
        _err "Reinstall: curl -sL https://raw.githubusercontent.com/veschin/GoLeM/main/install.sh | bash"
        exit 1
    fi

    local old_rev
    old_rev="$(git -C "$repo_dir" rev-parse --short HEAD)"
    _info "Updating GoLeM from $old_rev..."

    # Pull latest, fast-forward only
    local pull_output
    if ! pull_output=$(git -C "$repo_dir" pull --ff-only 2>&1); then
        _err "Cannot fast-forward. Local repo has diverged."
        echo "$pull_output" >&2
        echo ""
        _warn "Reinstall to fix:"
        echo "  curl -sL https://raw.githubusercontent.com/veschin/GoLeM/main/install.sh | bash"
        exit 1
    fi

    local new_rev
    new_rev="$(git -C "$repo_dir" rev-parse --short HEAD)"

    if [[ "$old_rev" == "$new_rev" ]]; then
        _info "Already up to date ($new_rev)"
    else
        _info "Updated $old_rev -> $new_rev"
        git -C "$repo_dir" log --oneline "$old_rev..$new_rev" | while IFS= read -r line; do
            echo "  - $line"
        done
    fi

    # Re-inject CLAUDE.md instructions
    local claude_md="${HOME}/.claude/CLAUDE.md"
    local glm_section
    glm_section="$(cat "$repo_dir/claude/CLAUDE.md")"
    local marker_start="<!-- GLM-SUBAGENT-START -->"
    local marker_end="<!-- GLM-SUBAGENT-END -->"

    if [[ -f "$claude_md" ]] && grep -q "$marker_start" "$claude_md"; then
        local tmp
        tmp="$(mktemp)"
        awk -v start="$marker_start" -v end="$marker_end" '
            $0 == start { skip=1; next }
            $0 == end   { skip=0; next }
            !skip { print }
        ' "$claude_md" > "$tmp"
        echo "" >> "$tmp"
        echo "$glm_section" >> "$tmp"
        mv "$tmp" "$claude_md"
        _info "CLAUDE.md instructions updated"
    fi

    echo ""
    _info "Done!"
}

cmd_session() {
    local opus="$OPUS_MODEL" sonnet="$SONNET_MODEL" haiku="$HAIKU_MODEL"
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -m|--model)  opus="$2"; sonnet="$2"; haiku="$2"; shift 2 ;;
            --opus)      opus="$2"; shift 2 ;;
            --sonnet)    sonnet="$2"; shift 2 ;;
            --haiku)     haiku="$2"; shift 2 ;;
            *)           args+=("$1"); shift ;;
        esac
    done

    env -u CLAUDECODE -u CLAUDE_CODE_ENTRYPOINT \
        ANTHROPIC_AUTH_TOKEN="$ZAI_API_KEY" \
        ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic" \
        API_TIMEOUT_MS="3000000" \
        ANTHROPIC_DEFAULT_OPUS_MODEL="$opus" \
        ANTHROPIC_DEFAULT_SONNET_MODEL="$sonnet" \
        ANTHROPIC_DEFAULT_HAIKU_MODEL="$haiku" \
        "$CLAUDE_BIN" "${args[@]+"${args[@]}"}"
}

case "${1:-}" in
    run)     shift; cmd_run "$@" ;;
    start)   shift; cmd_start "$@" ;;
    status)  shift; cmd_status "$@" ;;
    result)  shift; cmd_result "$@" ;;
    log)     shift; cmd_log "$@" ;;
    list)    shift; cmd_list "$@" ;;
    clean)   shift; cmd_clean "$@" ;;
    kill)    shift; cmd_kill "$@" ;;
    session) shift; cmd_session "$@" ;;
    update)  shift; cmd_update "$@" ;;
    *)
        cat <<'USAGE'
Usage: glm {session|run|start|status|result|log|list|clean|kill|update} [options]

Commands:
  session [flags] [claude flags]                 Interactive Claude Code
  run   [flags] "prompt"                         Sync execution
  start [flags] "prompt"                         Async execution
  status  JOB_ID                                 Check job status
  result  JOB_ID                                 Get text output
  log     JOB_ID                                 Show file changes
  list                                           List all jobs
  clean   [--days N]                             Remove old jobs
  kill    JOB_ID                                 Terminate job
  update                                         Self-update from GitHub

Flags:
  -d DIR              Working directory
  -t SEC              Timeout in seconds
  -m, --model MODEL   Set all three model slots to MODEL
  --opus MODEL        Set opus model
  --sonnet MODEL      Set sonnet model
  --haiku MODEL       Set haiku model
  --unsafe            Bypass all permission checks
  --mode MODE         Set permission mode (acceptEdits, default, plan)

Config: ~/.config/GoLeM/glm.conf
  GLM_MODEL=glm-4.7                # default for all slots
  GLM_OPUS_MODEL=glm-4.7           # override opus
  GLM_SONNET_MODEL=glm-4.7         # override sonnet
  GLM_HAIKU_MODEL=glm-4.7          # override haiku
  GLM_PERMISSION_MODE=acceptEdits  # default permission mode
  GLM_MAX_PARALLEL=3               # max concurrent agents (0=unlimited)

Per-job files:
  stdout.txt       Text result
  changelog.txt    File modifications log
  raw.json         Full JSON with all tool calls
USAGE
        exit 1
        ;;
esac
